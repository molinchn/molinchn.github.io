(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{363:function(_,v,t){"use strict";t.r(v);var a=t(4),s=Object(a.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"《linux高性能服务器编程》读书笔记"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#《linux高性能服务器编程》读书笔记"}},[_._v("#")]),_._v(" 《Linux高性能服务器编程》读书笔记")]),_._v(" "),v("h2",{attrs:{id:"目录"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#目录"}},[_._v("#")]),_._v(" 目录")]),_._v(" "),v("p",[_._v("本书分三篇：")]),_._v(" "),v("ul",[v("li",[_._v("第一篇，1-4章，介绍TCP/IP中重要的网络协议")]),_._v(" "),v("li",[_._v("第二篇，5-15章，剖析服务器编程的各个主要方面\n"),v("ul",[v("li",[_._v("5-7章 Linux API")]),_._v(" "),v("li",[_._v("8章 高性能服务器的一般框架（IO单元，逻辑单元，存储单元）")]),_._v(" "),v("li",[_._v("9-12章 剖析IO单元（IO事件，信号，定时，Libevent）")]),_._v(" "),v("li",[_._v("13-15章 多线程，多进程编程，进程池，线程池")])])]),_._v(" "),v("li",[_._v("第三篇，16-17章，探讨如何从系统的角度优化和检测服务器性能")])]),_._v(" "),v("p",[_._v("第一章 TCP/IP协议族")]),_._v(" "),v("p",[_._v("第二章 IP协议详解")]),_._v(" "),v("p",[_._v("第三章 TCP协议详解")]),_._v(" "),v("p",[_._v("第四章 TCP/IP通信案例：访问Internet上的Web服务器")]),_._v(" "),v("p",[_._v("第五章 Linux网络编程基础API")]),_._v(" "),v("p",[_._v("第六章 高级IO函数")]),_._v(" "),v("p",[_._v("第七章 Linux服务器程序规范")]),_._v(" "),v("p",[_._v("第八章 高性能服务器程序框架")]),_._v(" "),v("p",[_._v("第九章 IO复用")]),_._v(" "),v("p",[_._v("第十章 信号")]),_._v(" "),v("p",[_._v("第十一章 定时器")]),_._v(" "),v("p",[_._v("第十二章 高性能IO框架库Libevent")]),_._v(" "),v("p",[_._v("第十三章 多进程编程")]),_._v(" "),v("p",[_._v("第十四章 多线程编程")]),_._v(" "),v("p",[_._v("第十五章 进程池和线程池")]),_._v(" "),v("p",[_._v("第十六章 服务器调制，调试和测试")]),_._v(" "),v("p",[_._v("第十七章 系统监测工具")]),_._v(" "),v("p",[_._v("接下来分章节简要记录主要内容，留作个人回顾的“高速缓存”。")]),_._v(" "),v("p",[_._v("后面的章节下的子标题不以书中为依据，而是加入了个人的理解。")]),_._v(" "),v("h2",{attrs:{id:"第一章-tcp-ip协议族"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#第一章-tcp-ip协议族"}},[_._v("#")]),_._v(" 第一章 TCP/IP协议族")]),_._v(" "),v("h3",{attrs:{id:"_1-1-协议族"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-协议族"}},[_._v("#")]),_._v(" 1.1 协议族")]),_._v(" "),v("p",[_._v("首先是一张主要的图：")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://murray-pic-1254317211.cos.ap-guangzhou.myqcloud.com/gitee_bak/20210501233639.png",alt:""}})]),_._v(" "),v("ul",[v("li",[_._v("数据链路层：主要是ARP和RARP协议")]),_._v(" "),v("li",[_._v("网络层是IP协议，另外还要直到ICMP协议也是网络层的重要协议，它的一个重要应用就是ping")]),_._v(" "),v("li",[_._v("传输层：自然是TCP和UDP")]),_._v(" "),v("li",[_._v("应用层：首先是DNS非常重要，其次就是telnet，ssh等，还要知道OSPF协议用于动态路由更新")])]),_._v(" "),v("h3",{attrs:{id:"_1-2-封装与分用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-封装与分用"}},[_._v("#")]),_._v(" 1.2 封装与分用")]),_._v(" "),v("p",[_._v("封装指的就是数据发送到物理网络之前，从协议栈自顶向下传递的过程中，不同的协议加入头部信息的过程。")]),_._v(" "),v("p",[_._v("具体来说：数据 -> TCP报文段、UDP数据报 -> IP数据报 -> 以太网帧")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://murray-pic-1254317211.cos.ap-guangzhou.myqcloud.com/gitee_bak/20210501234542.png",alt:""}})]),_._v(" "),v("p",[_._v("分用则恰好是封装的反过程，这时帧到达主机后，被不同的协议依次处理，最终把对应的数据交到目标应用程序。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://murray-pic-1254317211.cos.ap-guangzhou.myqcloud.com/gitee_bak/20210501235211.png",alt:""}})]),_._v(" "),v("h3",{attrs:{id:"_1-3-数据链路层的arp协议"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-数据链路层的arp协议"}},[_._v("#")]),_._v(" 1.3 数据链路层的ARP协议")]),_._v(" "),v("p",[_._v("ARP协议实际上可以把任意网络层地址转换为物理地址，但是更多的是使用它从IP地址到以太网地址的过程。")]),_._v(" "),v("p",[_._v("它的工作原理很简单，就是将一个包含目标机器IP地址的信息广播给局域网内所有的机器，满足要求的则会返回，不满足要求的就无视该信息。如果一个局域网中没有这个地址，"),v("strong",[_._v("那么就会把该网络中的路由器解析为硬件地址")]),_._v("，"),v("strong",[_._v("然后把数据报传给它，此时对于请求设备已经结束了ARP和传输两个过程")]),_._v("。剩下的全部交给路由器，由它递归地执行ARP和传输的操作。")]),_._v(" "),v("h3",{attrs:{id:"_1-4-应用层的dns协议"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-应用层的dns协议"}},[_._v("#")]),_._v(" 1.4 应用层的DNS协议")]),_._v(" "),v("p",[_._v("DNS协议是根据网络域名得到对应目标主机的IP地址。")]),_._v(" "),v("p",[_._v("具体过程：")]),_._v(" "),v("ol",[v("li",[v("p",[_._v("查hosts。如果没有，进进入下一条。")])]),_._v(" "),v("li",[v("p",[_._v("查本地DNS缓存。如果没有，进进入下一条。")])]),_._v(" "),v("li",[v("p",[_._v("查本地DNS服务器（也叫首选DNS服务器）。如果没有，进进入下一条。")])]),_._v(" "),v("li",[v("p",[_._v("若开启转发，则转至上一级DNS服务器，依次循环。若未开启转发，则转至13台根DNS，本地会收到一个负责该顶级域名的服务器ip，进而由上到下查询。")])]),_._v(" "),v("li",[v("p",[_._v("最终本地DNS服务器返回查询结果给客户机。")])])]),_._v(" "),v("h3",{attrs:{id:"_1-5-socket在网络结构中的角色"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-5-socket在网络结构中的角色"}},[_._v("#")]),_._v(" 1.5 Socket在网络结构中的角色")]),_._v(" "),v("p",[_._v("首先Socket是一套API，并不是某个协议。它可以让应用程序能访问内核中的协议实现。如图所示，它存在于应用层和以下各层之间：")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://murray-pic-1254317211.cos.ap-guangzhou.myqcloud.com/gitee_bak/20210501233639.png",alt:""}})]),_._v(" "),v("p",[_._v("它有两个功能：")]),_._v(" "),v("ol",[v("li",[_._v("将数据从应用缓冲区复制到内核中的TCP或UDP缓冲区，进而发送。以及其反过程，用于读取接收到的数据。")]),_._v(" "),v("li",[_._v("修改内核中各层协议的头部信息或数据结构，精细控制通信行为。")])]),_._v(" "),v("h2",{attrs:{id:"第二章-ip协议"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#第二章-ip协议"}},[_._v("#")]),_._v(" 第二章 IP协议")]),_._v(" "),v("p",[_._v("第一章中提到了网络层重要的两个协议，一个是IP，还有一个ICMP。")]),_._v(" "),v("p",[_._v("在这里单独拿一章来讲IP协议可见其重要性。")]),_._v(" "),v("p",[_._v("IP协议的特点是："),v("strong",[_._v("无状态（同样无连接的还有HTTP协议），无连接，不可靠（UDP也是无连接且不可靠的）")])]),_._v(" "),v("h3",{attrs:{id:"_2-1-ipv4头部结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-ipv4头部结构"}},[_._v("#")]),_._v(" 2.1 IPv4头部结构")]),_._v(" "),v("p",[_._v("这部分没什么好说的，就是IPv4的头部数据。需要注意的是：")]),_._v(" "),v("ol",[v("li",[_._v("其长度也是20+40，原因是4bit的头部长度只能表示最大到15，而单位是4字节，也就是15个4字节 = 60字节。")]),_._v(" "),v("li",[_._v("IP数据报的最大长度是65535（16位）。")]),_._v(" "),v("li",[_._v("其中的TTL是生存时间（8位），实际上它是一个计数器，减到0则丢弃数据报。")])]),_._v(" "),v("h3",{attrs:{id:"_2-2-ip分片是什么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-ip分片是什么"}},[_._v("#")]),_._v(" 2.2 IP分片是什么")]),_._v(" "),v("p",[_._v("MTU：最大传输单元。")]),_._v(" "),v("p",[_._v("当IP数据报的长度超过帧的MTU时，就会被分片传输。")]),_._v(" "),v("p",[_._v("分片的位置可能是发送端，也可能是中专路由器上，也可能在中间多次被分片，只有在最终的目标机器上才会被重新组装。")]),_._v(" "),v("p",[_._v("被分片后，每个片都有自己的IP数据数据报头部，且有相同的标示值和不同的便宜。")]),_._v(" "),v("h3",{attrs:{id:"_2-3-ip-路由与转发-数据报如何找到目的机器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-ip-路由与转发-数据报如何找到目的机器"}},[_._v("#")]),_._v(" 2.3 IP 路由与转发（数据报如何找到目的机器）")]),_._v(" "),v("p",[_._v("路由的过程：")]),_._v(" "),v("ol",[v("li",[_._v("查找路由表中有没有和目标主机IP相同的主机，即目标主机。")]),_._v(" "),v("li",[_._v("查找有没有和目标主机IP具有相同网络ID（网关地址）的IP地址，有则转发。")]),_._v(" "),v("li",[_._v("选择默认路由，即网关。")])]),_._v(" "),v("h3",{attrs:{id:"_2-4-ipv6的特点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-ipv6的特点"}},[_._v("#")]),_._v(" 2.4 IPv6的特点")]),_._v(" "),v("ol",[v("li",[_._v("有128位的IP，v4中只有32位。这意味着每粒沙子都有自己的IP。")]),_._v(" "),v("li",[_._v("IPv6地址有16进制的：分割表示（4个16进制 * 8），如果遇到连续的0则省略对应段。但是省略只能有一个连续段。")])]),_._v(" "),v("h2",{attrs:{id:"第三章-tcp协议"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#第三章-tcp协议"}},[_._v("#")]),_._v(" 第三章 TCP协议")]),_._v(" "),v("p",[_._v("TCP的三个特点："),v("strong",[_._v("面向连接，字节流，可靠传输")])]),_._v(" "),v("p",[_._v("TCP可靠的点包括：")]),_._v(" "),v("ol",[v("li",[_._v("确认和超时重传机制")]),_._v(" "),v("li",[_._v("流量控制")]),_._v(" "),v("li",[_._v("拥塞控制")]),_._v(" "),v("li",[_._v("数据校验")])]),_._v(" "),v("h3",{attrs:{id:"_3-1-tcp的头部结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-tcp的头部结构"}},[_._v("#")]),_._v(" 3.1 TCP的头部结构")]),_._v(" "),v("p",[_._v("我觉得这个还是挺好记的。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://murray-pic-1254317211.cos.ap-guangzhou.myqcloud.com/gitee_bak/20210502152931.png",alt:""}})]),_._v(" "),v("p",[_._v("其中：")]),_._v(" "),v("ol",[v("li",[_._v("头部长度还是4位，这意味着20+40的头部长度。")]),_._v(" "),v("li",[_._v("6个标志位，其中有5个比较常见，包括ACK，PSH，RST，SYN，FIN。另一个不常见的是URG，它是表示右下角的紧急指针是否生效。这是TCP发送紧急数据的方法。")]),_._v(" "),v("li",[_._v("16位窗口大小，这是流量控制的首段，单位是字节。")]),_._v(" "),v("li",[_._v("校验和是TCP执行CRC的部分，是TCP可靠传输的重要保证之一。")])]),_._v(" "),v("h3",{attrs:{id:"_3-2-连接与断连"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-连接与断连"}},[_._v("#")]),_._v(" 3.2 连接与断连")]),_._v(" "),v("p",[_._v("三次握手与四次挥手，这里没什么好说的，直接上图。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://murray-pic-1254317211.cos.ap-guangzhou.myqcloud.com/gitee_bak/20210502153952.png",alt:""}})]),_._v(" "),v("p",[_._v("上下分别是三次握手和四次挥手的部分。")]),_._v(" "),v("h3",{attrs:{id:"_3-3-tcp超时重传"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-tcp超时重传"}},[_._v("#")]),_._v(" 3.3 TCP超时重传")]),_._v(" "),v("p",[v("strong",[_._v("首先要注意，有两种超时情况，第一种是建立连接前的超时，我们称之为”连接超时“。另一种就是建立连接后的超时，常称之为”超时重传“。")])]),_._v(" "),v("h3",{attrs:{id:"连接超时"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#连接超时"}},[_._v("#")]),_._v(" 连接超时")]),_._v(" "),v("p",[_._v("此时客户端与服务器还没有建立连接。")]),_._v(" "),v("p",[_._v("这里的机制和超时重传类似，但是我们还是要区分这两种情况。")]),_._v(" "),v("h3",{attrs:{id:"超时重传"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#超时重传"}},[_._v("#")]),_._v(" 超时重传")]),_._v(" "),v("p",[_._v("这里书上说得不明确，借用"),v("a",{attrs:{href:"https://github.com/linw7/Skill-Tree/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#trans",target:"_blank",rel:"noopener noreferrer"}},[_._v("其他地方"),v("OutboundLink")],1),_._v("的总结")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("超时重传：发送端发送报文后若长时间未收到确认的报文则需要重发该报文。可能有以下几种情况：")]),_._v(" "),v("ul",[v("li",[_._v("发送的数据没能到达接收端，所以对方没有响应。")]),_._v(" "),v("li",[_._v("接收端接收到数据，但是ACK报文在返回过程中丢失。")]),_._v(" "),v("li",[_._v("接收端拒绝或丢弃数据。")])])]),_._v(" "),v("li",[v("p",[_._v("RTO：从上一次发送数据，因为长期没有收到ACK响应，到下一次重发之间的时间。就是重传间隔。")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("通常每次重传RTO是前一次重传间隔的两倍")]),_._v("，计量单位通常是RTT。例：1RTT，2RTT，4RTT，8RTT......")]),_._v(" "),v("li",[v("strong",[_._v("重传次数到达上限之后停止重传")]),_._v("。")]),_._v(" "),v("li",[_._v("到达上限有两种。在5次内是由TCP控制。第5次重传后，如果还是失败，底层的IP和ARP开始接管，最多15次。")])])]),_._v(" "),v("li",[v("p",[_._v("RTT：数据从发送到接收到对方响应之间的时间间隔，即数据报在网络中一个往返用时。大小不稳定。")])])]),_._v(" "),v("p",[_._v("实际上，RTT的计算也比较复杂，但是这样大概理解是可以的。")]),_._v(" "),v("h3",{attrs:{id:"_3-4-tcp拥塞控制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-tcp拥塞控制"}},[_._v("#")]),_._v(" 3.4 TCP拥塞控制")]),_._v(" "),v("p",[_._v("包括慢开始，拥塞避免，快重传，快恢复。")]),_._v(" "),v("p",[_._v("这里是TCP比较重要的一部分内容。")]),_._v(" "),v("p",[_._v("首先必须明确："),v("strong",[_._v("拥塞控制的最终控制变量是发送窗口swnd（send window)，单位是字节数。")])]),_._v(" "),v("p",[_._v("而接收方可以通过rwnd（receive window)来控制swnd。但是这样仅仅是流量控制的内容，想要更细粒度的控制流量，即达到拥塞控制的目的，加入了cwnd(congestion window)。最终的swnd为")]),_._v(" "),v("p",[_._v("$$swnd = min(cwnd, swnd)$$")]),_._v(" "),v("p",[_._v("如下图：")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://murray-pic-1254317211.cos.ap-guangzhou.myqcloud.com/gitee_bak/20210502161111.png",alt:""}})]),_._v(" "),v("p",[_._v("下面就分别介绍不同部分的内容。")]),_._v(" "),v("h3",{attrs:{id:"慢开始"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#慢开始"}},[_._v("#")]),_._v(" 慢开始")]),_._v(" "),v("p",[_._v("慢开始的慢，指的是不要一下子把一个连接的swnd弄成rwnd，而是慢慢的增大。")]),_._v(" "),v("p",[_._v("这里涉及一个SMSS（sender maximum segment size）。指的是发送者最大段大小，单位是字节数。")]),_._v(" "),v("p",[_._v("具体来说，cwnd先控制为SMSS的2-4倍。然后每次收到一个确认，就进行$cwnd+=(N, SMSS)$。N是此次确认中包含之前未被确认的"),v("strong",[_._v("字节数")]),_._v("。")]),_._v(" "),v("p",[_._v("这样cwnd会以一个接近指数的方式增长起来（虽然每次增长的差不多，但是由于swnd的增加，增长的频度会增加）。")]),_._v(" "),v("p",[_._v("此时再定义一个变量叫ssthresh(slow start threshold size)，即慢启动门限。等到cwnd超过该值，则进入拥塞避免状态。")]),_._v(" "),v("h3",{attrs:{id:"拥塞避免"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#拥塞避免"}},[_._v("#")]),_._v(" 拥塞避免")]),_._v(" "),v("p",[_._v("拥塞避免的目的是减缓cwnd的增长速度。")]),_._v(" "),v("p",[_._v("具体策略：每收到一个确认，cwnd += SMSS*SMSS/cwnd。")]),_._v(" "),v("p",[_._v("这样会保证每个RTT增长1个SMSS，即进入加性增长阶段。")]),_._v(" "),v("p",[_._v("这时都没法发生拥塞，如果发生拥塞了，就会有两种解决路线，路线的选择在于发生了什么样的拥塞")]),_._v(" "),v("p",[_._v("拥塞发生的判断标准为：")]),_._v(" "),v("ul",[v("li",[_._v("传输超时（即没有按时收到ACK）— 继续使用慢启动和拥塞避免")]),_._v(" "),v("li",[_._v("收到重复的ACK（3个） — 使用快重传和快恢复")])]),_._v(" "),v("p",[_._v("如果是传输超时，那就直接进行两步：")]),_._v(" "),v("ol",[v("li",[_._v("慢开始门限设置成拥塞时发送窗口的一半（ssthresh减少）")]),_._v(" "),v("li",[_._v("cwnd = 1，重新进入慢开始。")])]),_._v(" "),v("p",[_._v("如果是收到了连续的ACK，就进入下面的快重传与快恢复。")]),_._v(" "),v("h3",{attrs:{id:"快重传与快恢复"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#快重传与快恢复"}},[_._v("#")]),_._v(" 快重传与快恢复")]),_._v(" "),v("p",[_._v("简而言之，收到3个重复ACK，则")]),_._v(" "),v("ol",[v("li",[_._v("直接重传丢失的报文段")]),_._v(" "),v("li",[_._v("ssthresh减半")]),_._v(" "),v("li",[_._v("cwnd = ssthresh，并进入拥塞避免算法")])]),_._v(" "),v("h2",{attrs:{id:"第四章-tcp-ip通信案例"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#第四章-tcp-ip通信案例"}},[_._v("#")]),_._v(" 第四章 TCP/IP通信案例")]),_._v(" "),v("p",[_._v("本章内容偏实践，没有认真读，但是要分清一下几个概念还是很重要的。")]),_._v(" "),v("p",[_._v("另外本章更注重的是应用层的内容。")]),_._v(" "),v("h3",{attrs:{id:"_4-1-什么是http代理服务器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-什么是http代理服务器"}},[_._v("#")]),_._v(" 4.1 什么是HTTP代理服务器")]),_._v(" "),v("ul",[v("li",[_._v("正向代理：客户端自己设置的代理服务器地址，客户的每次请求都会发送到正向代理服务器。")]),_._v(" "),v("li",[_._v("反向代理：设置在服务器端，作用是接收客户端的请求，并转发给内部网络服务器，并从内部服务上得到结果发送给客户端。")]),_._v(" "),v("li",[_._v("透明代理：设置在网关上，任意一方都要经过。")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://murray-pic-1254317211.cos.ap-guangzhou.myqcloud.com/gitee_bak/20210502164543.png",alt:""}})]),_._v(" "),v("h3",{attrs:{id:"_4-2-如何访问dns服务器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-如何访问dns服务器"}},[_._v("#")]),_._v(" 4.2 如何访问DNS服务器")]),_._v(" "),v("h3",{attrs:{id:"_4-2-http通信的主要内容"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-http通信的主要内容"}},[_._v("#")]),_._v(" 4.2 HTTP通信的主要内容")]),_._v(" "),v("h2",{attrs:{id:"第五章-linux网络编程api"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#第五章-linux网络编程api"}},[_._v("#")]),_._v(" 第五章 Linux网络编程api")]),_._v(" "),v("h2",{attrs:{id:"第六章-高级io函数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#第六章-高级io函数"}},[_._v("#")]),_._v(" 第六章 高级io函数")]),_._v(" "),v("h2",{attrs:{id:"第七章-linux服务器程序规范"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#第七章-linux服务器程序规范"}},[_._v("#")]),_._v(" 第七章 Linux服务器程序规范")]),_._v(" "),v("h2",{attrs:{id:"第八章-高性能服务器框架"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#第八章-高性能服务器框架"}},[_._v("#")]),_._v(" 第八章 高性能服务器框架")]),_._v(" "),v("h2",{attrs:{id:"第九章-io复用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#第九章-io复用"}},[_._v("#")]),_._v(" 第九章 IO复用")]),_._v(" "),v("h2",{attrs:{id:"第十章-信号"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#第十章-信号"}},[_._v("#")]),_._v(" 第十章 信号")]),_._v(" "),v("h2",{attrs:{id:"第十一章-定时器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#第十一章-定时器"}},[_._v("#")]),_._v(" 第十一章 定时器")]),_._v(" "),v("h2",{attrs:{id:"第十二章-高性能io框架库-libevent"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#第十二章-高性能io框架库-libevent"}},[_._v("#")]),_._v(" 第十二章 高性能IO框架库 libevent")]),_._v(" "),v("p",[_._v("google chromium用的库")]),_._v(" "),v("h2",{attrs:{id:"第十三章-多进程编程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#第十三章-多进程编程"}},[_._v("#")]),_._v(" 第十三章 多进程编程")]),_._v(" "),v("h2",{attrs:{id:"第十四章-多线程编程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#第十四章-多线程编程"}},[_._v("#")]),_._v(" 第十四章 多线程编程")]),_._v(" "),v("h2",{attrs:{id:"第十五章-进程池与线程池"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#第十五章-进程池与线程池"}},[_._v("#")]),_._v(" 第十五章 进程池与线程池")])])}),[],!1,null,null,null);v.default=s.exports}}]);