(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{343:function(a,t,e){"use strict";e.r(t);var r=e(4),v=Object(r.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"spring框架"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring框架"}},[a._v("#")]),a._v(" Spring框架")]),a._v(" "),t("p",[a._v("本文作为我学习并使用Spring的知识梳理。")]),a._v(" "),t("h2",{attrs:{id:"spring的介绍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring的介绍"}},[a._v("#")]),a._v(" Spring的介绍")]),a._v(" "),t("h2",{attrs:{id:"_2-ioc容器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-ioc容器"}},[a._v("#")]),a._v(" 2. IoC容器")]),a._v(" "),t("h3",{attrs:{id:"_2-1-ioc是什么意思"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-ioc是什么意思"}},[a._v("#")]),a._v(" 2.1 IoC是什么意思")]),a._v(" "),t("p",[a._v("IoC，即Inversion of Control的简称。指的是控制反转。")]),a._v(" "),t("p",[a._v("关于这一部分的讲解：https://www.liaoxuefeng.com/wiki/1252599548343744/1282381977747489")]),a._v(" "),t("p",[a._v("在过往的语言使用中，我们通常是由开发者首先知道我要创建什么对象，然后去构造它。在构造的过程中会不断有这个对象所依赖的对象，我们又要构造这个依赖。这样下去，依赖，依赖的依赖，依赖的……（禁止套娃）。这就存在了严重的问题，甚至导致程序没法写下去。")]),a._v(" "),t("p",[a._v("这个时候，IoC解决了「开发者控制对象」这件事。Spring利用「IoC容器」来控制对象，而不再是开发者，这就是「控制反转」的大体意思。")]),a._v(" "),t("h3",{attrs:{id:"_2-2-ioc容器是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-ioc容器是什么"}},[a._v("#")]),a._v(" 2.2 IoC容器是什么")]),a._v(" "),t("p",[a._v("IoC容器就是Spring的主体。")]),a._v(" "),t("p",[a._v("这里借用"),t("a",{attrs:{href:""}},[a._v("这里")]),a._v("的一段话对容器进行描述。")]),a._v(" "),t("blockquote",[t("p",[a._v("什么是容器？容器是一种为某种特定组件的运行提供必要支持的一个软件环境。例如，Tomcat就是一个Servlet容器，它可以为Servlet的运行提供运行环境。类似Docker这样的软件也是一个容器，它提供了必要的Linux环境以便运行一个特定的Linux进程。")]),a._v(" "),t("p",[a._v("通常来说，使用容器运行组件，除了提供一个组件运行环境之外，容器还提供了许多底层服务。例如，Servlet容器底层实现了TCP连接，解析HTTP协议等非常复杂的服务，如果没有容器来提供这些服务，我们就无法编写像Servlet这样代码简单，功能强大的组件。早期的JavaEE服务器提供的EJB容器最重要的功能就是通过声明式事务服务，使得EJB组件的开发人员不必自己编写冗长的事务处理代码，所以极大地简化了事务处理。")]),a._v(" "),t("p",[a._v("Spring的核心就是提供了一个IoC容器，"),t("strong",[a._v("它可以管理所有轻量级的JavaBean组件，提供的底层服务包括组件的生命周期管理、配置和组装服务")]),a._v("、AOP支持，以及建立在AOP基础上的声明式事务服务等。")])]),a._v(" "),t("p",[a._v("另外要说一下什么是Bean，摘自：https://www.awaimai.com/2596.html")]),a._v(" "),t("blockquote",[t("p",[a._v("在 Spring 中，构成应用程序"),t("strong",[a._v("主干")]),a._v("并由"),t("strong",[a._v("Spring IoC容器")]),a._v("管理的"),t("strong",[a._v("对象")]),a._v("称为"),t("strong",[a._v("bean")]),a._v("。bean是一个由Spring IoC容器实例化、组装和管理的对象。")])]),a._v(" "),t("p",[a._v("概念简单明了，我们提取处关键的信息：")]),a._v(" "),t("ol",[t("li",[a._v("bean是对象，一个或者多个不限定")]),a._v(" "),t("li",[a._v("bean由Spring中一个叫IoC的东西管理")]),a._v(" "),t("li",[a._v("我们的应用程序由一个个bean构成")])]),a._v(" "),t("h3",{attrs:{id:"_2-3-使用xml配置文件控制装配"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-使用xml配置文件控制装配"}},[a._v("#")]),a._v(" 2.3 使用xml配置文件控制装配")]),a._v(" "),t("h3",{attrs:{id:"_2-4-更简单的装配方式-使用注解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-更简单的装配方式-使用注解"}},[a._v("#")]),a._v(" 2.4 更简单的装配方式：使用注解")]),a._v(" "),t("h3",{attrs:{id:"_2-5-与ioc容器相关的常见注解整理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-与ioc容器相关的常见注解整理"}},[a._v("#")]),a._v(" 2.5 与IoC容器相关的常见注解整理")]),a._v(" "),t("h4",{attrs:{id:"component"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#component"}},[a._v("#")]),a._v(" @Component")]),a._v(" "),t("p",[a._v("定义了一个Bean，它有一个可选的名称，默认是小写开头的类名。")]),a._v(" "),t("h4",{attrs:{id:"autowired"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#autowired"}},[a._v("#")]),a._v(" @Autowired")]),a._v(" "),t("p",[a._v("自动装配。")]),a._v(" "),t("p",[t("code",[a._v("@Autowired")]),a._v("就相当于把指定类型的Bean注入到指定的字段中。")]),a._v(" "),t("p",[a._v("如果写成这样：")]),a._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[a._v("@Autowired")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("required "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token boolean"}},[a._v("false")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br")])]),t("p",[a._v("那么这个类如果没有对应的Bean也不会报错。否则会报NoSuchBeanDefinitionException的异常。")]),a._v(" "),t("h4",{attrs:{id:"value"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#value"}},[a._v("#")]),a._v(" @Value")]),a._v(" "),t("p",[a._v("用于基本类型")]),a._v(" "),t("h4",{attrs:{id:"configuration"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#configuration"}},[a._v("#")]),a._v(" @Configuration")]),a._v(" "),t("p",[a._v("修饰一个类，说明这个class是一个配置类。")]),a._v(" "),t("p",[a._v("【什么是配置类】我的理解就是存在main方法的那个主类。")]),a._v(" "),t("h4",{attrs:{id:"componentscan"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#componentscan"}},[a._v("#")]),a._v(" @ComponentScan")]),a._v(" "),t("p",[a._v("这个注解很重要，它告诉容器，自动搜索"),t("strong",[a._v("当前类所在的包")]),a._v("以及"),t("strong",[a._v("子包")]),a._v("，把所有标注为"),t("code",[a._v("@Component")]),a._v("的Bean自动创建出来，并根据"),t("code",[a._v("@Autowired")]),a._v("进行装配。")]),a._v(" "),t("p",[a._v("到此为止，注解可以完成基本工作了，我们只要保证：")]),a._v(" "),t("ul",[t("li",[a._v("每个Bean被标注为"),t("code",[a._v("@Component")]),a._v("并正确使用"),t("code",[a._v("@Autowired")]),a._v("注入；")]),a._v(" "),t("li",[a._v("配置类被标注为"),t("code",[a._v("@Configuration")]),a._v("和"),t("code",[a._v("@ComponentScan")]),a._v("；")]),a._v(" "),t("li",[a._v("所有Bean均在指定包以及子包内。")])]),a._v(" "),t("p",[a._v("使用"),t("code",[a._v("@ComponentScan")]),a._v("非常方便，"),t("strong",[a._v("但是，我们也要特别注意包的层次结构")]),a._v("。通常来说，"),t("strong",[a._v("启动配置"),t("code",[a._v("AppConfig")]),a._v("位于自定义的顶层包（例如"),t("code",[a._v("com.itranswarp.learnjava")]),a._v("），其他Bean按类别放入子包。")])]),a._v(" "),t("p",[a._v("其他的重要注解有：")]),a._v(" "),t("h4",{attrs:{id:"scope"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#scope"}},[a._v("#")]),a._v(" @Scope")]),a._v(" "),t("p",[a._v("当一个类被直接作为Component时，它只会被创建一次。每次getbean都是调用同一个类。若不想这样，就要使用：")]),a._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[a._v("@Scope")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("ConfigurableBeanFactory")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("SCOPE_PROTOTYPE")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br")])]),t("p",[a._v("这样可以使得每次调用时创建不同的对象。")]),a._v(" "),t("h4",{attrs:{id:"bean"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#bean"}},[a._v("#")]),a._v(" @Bean")]),a._v(" "),t("p",[a._v("用来声明标注一个「方法」，这个方法只会被调用一次。")]),a._v(" "),t("p",[a._v("通常用来创建第三方的Bean。")]),a._v(" "),t("p",[a._v("参考：https://www.liaoxuefeng.com/wiki/1252599548343744/1308043627200545")]),a._v(" "),t("h4",{attrs:{id:"postconstruct"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#postconstruct"}},[a._v("#")]),a._v(" @PostConstruct")]),a._v(" "),t("p",[a._v("初始化")]),a._v(" "),t("h4",{attrs:{id:"predestroy"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#predestroy"}},[a._v("#")]),a._v(" @PreDestroy")]),a._v(" "),t("p",[a._v("销毁")]),a._v(" "),t("h4",{attrs:{id:"qualifier"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#qualifier"}},[a._v("#")]),a._v(" @Qualifier")]),a._v(" "),t("p",[a._v("可以用"),t("code",[a._v('@Bean("name")')]),a._v("指定别名，也可以用"),t("code",[a._v("@Bean")]),a._v("+"),t("code",[a._v('@Qualifier("name")')]),a._v("指定别名。")]),a._v(" "),t("h4",{attrs:{id:"primary"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#primary"}},[a._v("#")]),a._v(" @Primary")]),a._v(" "),t("p",[a._v("如果没有指出Bean的名字，Spring会注入标记有"),t("code",[a._v("@Primary")]),a._v("的Bean。这种方式也很常用。例如，对于主从两个数据源，通常将主数据源定义为"),t("code",[a._v("@Primary")])]),a._v(" "),t("h4",{attrs:{id:"propertysource"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#propertysource"}},[a._v("#")]),a._v(" @PropertySource")]),a._v(" "),t("p",[a._v("自动读取配置文件")]),a._v(" "),t("h4",{attrs:{id:"profile"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#profile"}},[a._v("#")]),a._v(" @Profile")]),a._v(" "),t("p",[a._v("控制条件装配，例如分离开发，测试，生产环境。")]),a._v(" "),t("p",[t("code",[a._v('@Profile("test")')]),a._v("表示test环境")]),a._v(" "),t("p",[t("code",[a._v('@Profile("!test")')]),a._v("表示非test环境。")]),a._v(" "),t("p",[a._v("在运行程序时，加上JVM参数"),t("code",[a._v("-Dspring.profiles.active=test")]),a._v("就可以指定以"),t("code",[a._v("test")]),a._v("环境启动。")]),a._v(" "),t("h4",{attrs:{id:"conditional"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#conditional"}},[a._v("#")]),a._v(" @Conditional")]),a._v(" "),t("p",[a._v("决定是否创建某个Bean。")]),a._v(" "),t("p",[a._v("例如"),t("code",[a._v("@Conditional(OnSmtpEnvCondition.class)")]),a._v("表示必须满足OnSmtpEnvCondition条件时才会创建这个Bean")]),a._v(" "),t("h2",{attrs:{id:"_3-aop"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-aop"}},[a._v("#")]),a._v(" 3. AOP")]),a._v(" "),t("h4",{attrs:{id:"_3-x-使用aop的步骤"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-x-使用aop的步骤"}},[a._v("#")]),a._v(" 3.x 使用AOP的步骤")]),a._v(" "),t("p",[a._v("虽然Spring容器内部实现AOP的逻辑比较复杂（需要使用AspectJ解析注解，并通过CGLIB实现代理类），但我们使用AOP非常简单，一共需要三步：")]),a._v(" "),t("ol",[t("li",[a._v("定义执行方法，并在方法上通过AspectJ的注解告诉Spring应该在何处调用此方法；")]),a._v(" "),t("li",[a._v("标记"),t("code",[a._v("@Component")]),a._v("和"),t("code",[a._v("@Aspect")]),a._v("；")]),a._v(" "),t("li",[a._v("在"),t("code",[a._v("@Configuration")]),a._v("类上标注"),t("code",[a._v("@EnableAspectJAutoProxy")]),a._v("。")])]),a._v(" "),t("h4",{attrs:{id:"拦截器种类及其注解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#拦截器种类及其注解"}},[a._v("#")]),a._v(" 拦截器种类及其注解")]),a._v(" "),t("ul",[t("li",[a._v("@Before：这种拦截器**先执行拦截代码，再执行目标代码。**如果拦截器抛异常，那么目标代码就不执行了；")]),a._v(" "),t("li",[a._v("@After：这种拦截器**先执行目标代码，再执行拦截器代码。**无论目标代码是否抛异常，拦截器代码都会执行；")]),a._v(" "),t("li",[a._v("@AfterReturning：和@After不同的是，"),t("strong",[a._v("只有当目标代码正常返回时，才执行拦截器代码")]),a._v("；")]),a._v(" "),t("li",[a._v("@AfterThrowing：和@After不同的是，"),t("strong",[a._v("只有当目标代码抛出了异常时，才执行拦截器代码")]),a._v("；")]),a._v(" "),t("li",[a._v("@Around：能完全控制目标代码是否执行，并可以在执行前后、抛异常后执行任意拦截代码，可以说是包含了上面所有功能。")])]),a._v(" "),t("h4",{attrs:{id:"_3-x-与aop相关的注解整理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-x-与aop相关的注解整理"}},[a._v("#")]),a._v(" 3.x 与AOP相关的注解整理")]),a._v(" "),t("h4",{attrs:{id:"enableaspectjautoproxy-before和-around"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#enableaspectjautoproxy-before和-around"}},[a._v("#")]),a._v(" @EnableAspectJAutoProxy + @Before和@Around")])])}),[],!1,null,null,null);t.default=v.exports}}]);